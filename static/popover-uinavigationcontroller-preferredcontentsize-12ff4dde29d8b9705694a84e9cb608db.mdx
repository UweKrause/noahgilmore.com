---
title: Popovers, UINavigationController, and preferredContentSize
date: 2019-08-26
tags: ios, swift, popover, uinavigationcontroller, preferredcontentsize
staticPreview: TODO
mdxPreview: >
    TODO
---
import CaptionedImage from '../../components/CaptionedImage';
import FlowGrid from '../../components/FlowGrid';

In this post we'll look at a very specific but tricky interaction in UIKit, one which took me multiple days to work out how to implement.

It's two view controllers of different sizes, pushed on a `UINavigationController`, which is presented as a popover. The view controllers have different sizes (defined by autolayout), only one of them displays a nav bar, and the popover animates when their sizes change - including when they get pushed onto the nav stack, where the resize animation happens at the same time as the push:

<CaptionedImage max={400} filename="popover-finished.gif" alt="Finished presentation of UIViewControllers with different content sizes inside a popover" caption="" />

Surprisingly this is very tricky to implement in UIKit, and it ties together a lot of concepts that I wasn't really familiar with until I ran into this case.

> The finished code for this interaction is available at TODO. If you're looking for the relevant `UINavigationController` wrapper, it's at the bottom of this post.

# Motivation

At work, we do a fair amount of presenting view controllers as popovers to add context or more data to our existing iPad view. A common flow is the following:

1. Present a small popover to add more context to something the user tapped.
2. When the user taps on a button in that popover, push on a new view controller with more information.

Seems easy enough, but the kicker is when _the two view controllers are different sizes_.

Let's assume we have two view controllers to present: one 300x300 with a red background and no navigation bar content, and one 600x400 with a green background and a nav bar title. Here's what we want them to look like:

<CaptionedImage max={300} filename="red-controller.png" alt="Red view controller" caption="SmallViewControllerNoNavBar" />
<CaptionedImage max={500} filename="green-controller.png" alt="Green view controller" caption="LargeViewControllerWithNavBar" />

# preferredContentSize
Let's start with the red controller.

Setting up the width and height is easy enough with autolayout (or so you might think):

```swift
override func viewDidLoad() {
    // ...
    self.view.widthAnchor.constraint(
        equalToConstant: 300
    ).isActive = true
    self.view.heightAnchor.constraint(
        equalToConstant: 300
    ).isActive = true
}
```

We'll set the navigation bar hidden in `viewWillAppear`:

```swift
override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
    self.navigationController?.setNavigationBarHidden(true, animated: false)
}
```

And, from the main controller, present our green view as a popover:

```swift
let containerController = UINavigationController(rootViewController: firstVC)
containerController.modalPresentationStyle = .popover
// ... set the sourceView, sourceRect, etc
self.present(containerController, animated: true)
```

Unfortunately, this doesn't exactly produce the effect we're going for:

<CaptionedImage max={500} filename="red-controller-1.png" alt="Red view controller displaying in a popover with the wrong height and width" caption="Interesting" />

## preferredContentSize + autolayout
Our red view controller doesn't have the right size because when `UIViewController`s are presented as popovers, the popover's size is determined by the controller's `preferredContentSize` TODOsource. Since we haven't set `self.preferredContentSize` in our controller, the system uses the default of TODOxTODO TODOsource.

To fix this, we have to trigger a layout pass to determine our autolayout-defined size (TODO is there a better way?? preferredContentSize autolayout), and we can set that as our preferred size:

```swift
override func viewWillAppear(_ animated: Bool) {
    // ...
    self.preferredContentSize = self.view.systemLayoutSizeFitting(
        UIView.layoutFittingCompressedSize
    )
}
```

Assuming we've implemented the same thing in our green view controller (with different height and width, of course), we now get our controllers displaying their correct sizes! Unfortunately, the animation is a little weird:

<CaptionedImage max={500} filename="popover-animation-1.gif" alt="Red view controller with the right size, pushing on a green view controller, whose size starts the same as the red controller but expands when finished pushing." caption="Also interesting" />

# UINavigationController animations
It seems that `UINavigationController` queues the animations for pushing on a new view controller and setting its own `preferredContentSize` based off of the controller being pushed, so the push animation and the resize animation happen in series. This looks a little weird though - ideally we'd like them to happen simultaneously.

After quite a bit of spelunking online, I realized that `UINavigationController` just doesn't support this use case. However, I stumbled across TODO GIT REPO by TODO, which noted that you can get the resize to happen at the same time if you encapsulate the `UINavigationController` in a parent view controller! The flow looks like this:

1. We have a parent `UIViewController` wrapping our `UINavigationController`.
2. When the navigation controller is about to show a new view controller, we'll set the wrapper view controller's `preferredContentSize` to mirror the child's `preferredContentSize`.

## Wrapping the nav controller
Our wrapper controller looks like this:

```swift
final class PopoverPushController: UIViewController {
    private let wrappedNavigationController: PopoverPushNavigationController

    init(rootViewController: UIViewController) {
        self.wrappedNavigationController = PopoverPushNavigationController(
            rootViewController: rootViewController
        )
        super.init(nibName: nil, bundle: nil)
        self.wrappedNavigationController.delegate = self
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        wrappedNavigationController.willMove(toParent: self)
        self.addChild(wrappedNavigationController)
        self.view.addSubview(wrappedNavigationController.view)
    }

    // ...
}
```

When our container controller's view loads, we simply add the navigation controller's view as a subview, after using `willMove(toParent:)` and `addChild()` to add the navigation controller as a child view controller. TODO docs links for these

We also need the implementation of `UINavigationControllerDelegate` to respond to when the navigation controller is about to show a new view controller. `UINavigationControllerDelegate`'s methods are all optional, but we want to implement `willShow`:

```swift
extension PopoverPushController: UINavigationControllerDelegate {
    func navigationController(
        _ navigationController: UINavigationController,
        willShow viewController: UIViewController, animated: Bool
    ) {
        self.preferredContentSize = viewController.preferredContentSize
    }
}
```

And finally, we'll change our presentation code to present the `PopoverPushController` wrapper instead of the regular navigation controller:

```swift
let containerController = PopoverPushController(rootViewController: firstVC)
containerController.modalPresentationStyle = .popover
// ... set the sourceView, sourceRect, etc
self.present(containerController, animated: true)
```

Where does this get us? Well, we have the simultaneous animation we want:

<CaptionedImage max={500} filename="popover-animation-2.gif" alt="Red view controller transitioning to green view controller with size animating at the same time as the push animation." caption="ðŸŽ‰" />

## Updating the size
Everything's well and good now, so we can implement the last part of the interaction: resizing the green controller on button tap. Our code isn't particularly complicated, but we'll use the same autolayout technique from the red controller:

```swift
func setPreferredContentSizeFromAutolayout() {
    self.preferredContentSize = self.view.systemLayoutSizeFitting(
        UIView.layoutFittingCompressedSize
    )
}

var isExpanded: Bool = false {
    didSet {
        let constant = self.isExpanded ? 600 : 400
        self.heightConstraint.constant = constant
        self.setPreferredContentSizeFromAutolayout()
    }
}

@objc private func didTap() {
    self.isExpanded = !self.isExpanded
}
```

But now we've got a new problem: the popover size doesn't animate!

<CaptionedImage max={500} filename="popover-animation-3.gif" alt="Green view controller updating height, but without animation." caption="We were expecting a smooth animation" />

## Informing the presented view controller
The issue we have here is that our green view controller is changing its `preferredContentSize`, but _the popover view controller doesn't know it changed_. In an ideal world, we'd have `PopoverPushController` respond to the green controller's content size change, and _update its own `preferredContentSize`_ in response - since the `PopoverPushController` is the one presented as a popover, this change will trigger the animation.

There are a few ways to work this out, but a simple one is to employ `UIContentContainer`. `UIContentContainer` is a protocol (adopted by `UIViewController`) that encapsulates all the methods which `UIViewController` uses to respond to changes in a child view controller's content.

The method we're interested in in `preferredContentSizeDidChange`, which is called when a child view controller's `preferredContentSize` changes. We'll employ it in two ways:

1. A `UINavigationController` subclass will implement `preferredContentSizeDidChange` and set its own `preferredContentSize` to that of the view controller it's showing.
2. `PopoverPushController` will implement `preferredContentSizeDidChange` to do the same thing.

TODO this section is about implementing the nav controller subclass so that shit works out and the controller contracts and expands correctly

# Caveats

# Conclusion