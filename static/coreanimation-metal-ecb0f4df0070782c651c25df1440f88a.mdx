---
instabugEnabled: true
title: Animating Metal Content with CoreAnimation
date: 2019-11-25
tags: ios, swift, metal
staticPreview: TODO
mdxPreview:
    TODO
---
Recently, I've been learning more about Metal - I'm still working through the basics, but I've written a couple of posts and tweets (TODO links) about it, and I'm about halfway through Metal By Example (TODO link). Up until now I've mostly been coding sample projects, but I recently had the opportunity to prototype a Metal implementation integrated into our production app at work.

One thing I hadn't considered until I had to implement Metal in a real app was animations - when another part of our interface animated, we wanted to scale the Metal content along with an animation. This post will dive into how to adapt the CALayer animation system to work with a custom Metal view, and along the way we'll see a situation which Swift can't handle without hacks. (ðŸ˜±)

Our goal will be to build a triangle that animates to a new scale when a button is pressed:

TODO gif

> Full sample code is available for this project at TODO

## Getting started
Our sample project will follow the architecture adapted from the Xcode default Metal project (what Xcode gives you after New Project > Cross Platform Game):

1. We'll have a `Renderer` with a `draw(drawable:)` method which is responsible for issuing Metal draw calls with the `drawable` as a target. The renderer will have a `triangleScale` property
2. We'll have a custom view with a `CAMetalLayer` (TODO Link) subclass, and we'll override the layer's `display()` to call `draw`, passing the drawable from `nextDrawable` (TODO link)

(Note: we need a `CAMetalLayer` instead of an `MTKView` (TODO Link) here, for reasons I'll get into at the end of this post.)

```swift
class CustomCAMetalLayer: CAMetalLayer {
    private var renderer: Renderer!

    override init() {
        super.init()
        self.device = MTLCreateSystemDefaultDevice()!
        self.renderer = Renderer(device: self.device!)
        self.setNeedsDisplay()
    }

    /// Block the current thread until this layer has a drawable ready.
    private func blockRequestingNextDrawable() -> CAMetalDrawable {
        var drawable: CAMetalDrawable? = nil
        while (drawable == nil) {
            drawable = self.nextDrawable()
        }
        return drawable!
    }

    override func display() {
        let drawable = self.blockRequestingNextDrawable()
        self.renderer.draw(drawable: drawable)
    }
}

class MetalView: UIView {
    override class var layerClass: AnyClass {
        return CustomCAMetalLayer.self
    }
}
```

We set up our renderer in init, wait for a drawable to become available, and use our renderer to draw the triangle. The renderer code is more verbose since Metal requires quite a lot of code to set up a command queue, vertex buffers, etc, but you can view the code here (TODO link) if you like - it creates a buffer of three vertices for the points of the triangle, and the fragment shader shades them blue.

TODO image

## CALayer animations
CoreAnimation is the framework that powers `CALayer` and the other content that is used to implement `UIView`. Changes in a `CALayer` (like setting a new position or background color) are initiated by changing the layer's properties.

Many layer properties are animatable, which means that when they're changed, CoreAnimation will interpolate between the old value and the new value to animate the change. If you've ever tried to change the background color of a `UIView`'s layer directly (using `self.layer.backgroundColor`), you might notice that the change isn't instant - there's a subtle fade. Animatable `CALayer` properties all have default, "implicit" animations.

For our triangle, we'll be adding a custom layer property, which we'll call `triangleScale` - this will represent the scale of our triangle, which we want to animate between 1 and 2 to double the size:

```swift
class CustomCAMetalLayer: CAMetalLayer {
    // ...
    var triangleScale: CGFloat

    override init() {
        self.triangleScale = 1
        // ...
    }

    override func display() {
        self.renderer.triangleScale = Float(triangleScale)
        // ...
    }
}
```

Our button callback sets the new value:

```swift
    @objc private func didTapButton() {
        layer.triangleScale = 1.9
    }
```

And when we run the app and click the button, we get...

TODO image

...nothing!

## Customizing layer animations

## Dynamic properties in Swift
TODO this talks about implementing dynamic properties in Swift using @NSManaged

## Using presentation layers
TODO this part talks about how to use .presentation() to get the effective scale

## More complicated animations
TODO this part is about adapting the system to the cube

## Keyframes
Using CALayer properties to implement our animations means that we can hook into the entire CoreAnimation ecosystem, and one benefit of this is that we get keyframe animations for free!

TODO

## Conclusion


