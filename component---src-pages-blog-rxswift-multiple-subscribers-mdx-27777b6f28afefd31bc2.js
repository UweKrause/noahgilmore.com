(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{144:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",function(){return m});var a=t(156),r=t.n(a),o=t(0),s=t.n(o),i=t(157),c=t(158);n.default=function(e){var n=e.components,t=r()(e,["components"]);return s.a.createElement(i.MDXTag,{name:"wrapper",Layout:c.a,layoutProps:t,components:n},s.a.createElement(i.MDXTag,{name:"p",components:n},'Or, "how to not make unnecessary requests with a URLSession subscriber".'),s.a.createElement(i.MDXTag,{name:"p",components:n},"I've been working on a side project for ",s.a.createElement(i.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://twitter.com/noahsark769/status/1066878101907419137"}},"better CIFilter documentation")," lately, and I decided this was as good of a time as any to try out ",s.a.createElement(i.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/ReactiveX/RxSwift"}},"RxSwift"),". Even though reactive programming is becoming more and more common in native app development, I've never had a chance to really dig into it, so I started by going through RxSwift's ",s.a.createElement(i.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md"}},"intro documentation"),"."),s.a.createElement(i.MDXTag,{name:"h2",components:n},"Multiple Subscribers"),s.a.createElement(i.MDXTag,{name:"p",components:n},"One thing that wasn't immediately intuitive to me about Observables is that any time ",s.a.createElement(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"subscribe")," is called, the observable's creation block gets called again, even for Observables which perform asynchronous work. Take a simple observable that generates integers as an example:"),s.a.createElement(i.MDXTag,{name:"pre",components:n},s.a.createElement(i.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-swift",metaString:""}},'func generateRandomIntAfterDelay() -> Observable<Int> {\n    return Observable.create { observer in\n        print("Processing request...")\n        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2) {\n            print("Generating random int...")\n            observer.onNext(Int.random(in: 0 ..< 10))\n            observer.onCompleted()\n        }\n        return Disposables.create()\n    }\n}\n')),s.a.createElement(i.MDXTag,{name:"p",components:n},"If you have multiple subscribers to this observable, that means multiple units of work will get enqueued, and multiple random ints will get returned. I.e., if our subscription code looks like this:"),s.a.createElement(i.MDXTag,{name:"pre",components:n},s.a.createElement(i.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-swift",metaString:""}},'let observable = generateRandomIntAfterDelay()\nobservable.subscribe(onNext: { randInt in\n    print("1: Got (randInt)")\n})\nobservable.subscribe(onNext: { randInt in\n    print("2: Got (randInt)")\n})\n')),s.a.createElement(i.MDXTag,{name:"p",components:n},"Then the output will look like this:"),s.a.createElement(i.MDXTag,{name:"pre",components:n},s.a.createElement(i.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-nohighlight",metaString:""}},"Processing request...\nProcessing request...\nGenerating random int...\n1: Got 7\nGenerating random int...\n2: Got 2\n")),s.a.createElement(i.MDXTag,{name:"p",components:n},"For some reason, I assumed that for async observables, two subscriptions would result in two outputs, but for the same async result - this is just not how observable subscriptions work."),s.a.createElement(i.MDXTag,{name:"h2",components:n},"Observable URLSession Tasks"),s.a.createElement(i.MDXTag,{name:"p",components:n},"This situation gets a little trickier when you have an observable which performs real work, like making http requests:"),s.a.createElement(i.MDXTag,{name:"pre",components:n},s.a.createElement(i.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-swift",metaString:""}},'extension Reactive where Base: URLSession {\n    public func response(urlString: String) -> Observable<Data> {\n        return Observable.create { observer in\n            let task = self.base.dataTask(\n                with: URLRequest(url: URL(string: urlString)!)\n            ) { (data, response, error) in\n                guard let data = data else {\n                    return\n                }\n                observer.onNext(data)\n                observer.onCompleted()\n            }\n            task.resume()\n            return Disposables.create {\n                task.cancel()\n            }\n        }\n    }\n}\n\nfunc makeRequest() {\n    let observable = URLSession.shared.rx.response(\n        urlString: "https://noahgilmore.com"\n    )\n    observable.subscribe(onNext: { data in\n        print("Got the data!")\n    })\n    observable.subscribe(onNext: { data in\n        print("Got the data again!")\n    })\n}\n')),s.a.createElement(i.MDXTag,{name:"p",components:n},"One call to ",s.a.createElement(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"makeRequest()")," will make ",s.a.createElement(i.MDXTag,{name:"em",components:n,parentName:"p"},"two")," HTTP requests and get back two separate data objects. I started to wonder about how you would correctly implement multiple subscribers for an single HTTP request - it turns out an easy way is to use ",s.a.createElement(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ConnectableObservable"),', an "observable sequence that shares a single subscription to the underlying sequence"',s.a.createElement(i.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/ReactiveX/RxSwift/blob/53cd723d40d05177e790c8c34c36cec7092a6106/RxSwift/Observables/Multicast.swift#L54"}},"[1]"),". Calling ",s.a.createElement(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"publish()")," on any observable returns a ",s.a.createElement(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ConnectableObservable")," which mirrors it, and you can start the sequence with ",s.a.createElement(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},".connect()"),". This means you can implement multiple subscriptions for a single unit of work like this:"),s.a.createElement(i.MDXTag,{name:"pre",components:n},s.a.createElement(i.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-swift",metaString:""}},'func makeRequest() {\n    let observable = URLSession.shared.rx.response(\n        urlString: "https://noahgilmore.com"\n    )\n    let connectableObservable = observable.publish()\n    connectableObservable.subscribe(onNext: { data in\n        print("Got the data!")\n    })\n    connectableObservable.subscribe(onNext: { data in\n        print("Got the data again!")\n    })\n\n    // Start the request\n    connectableObservable.connect()\n}\n')),s.a.createElement(i.MDXTag,{name:"p",components:n},"This code correctly only makes one HTTP request with two callbacks. ðŸ‘Œ"),s.a.createElement(i.MDXTag,{name:"p",components:n},"This isn't the only time ",s.a.createElement(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},".publish()")," is useful though - like ",s.a.createElement(i.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://stackoverflow.com/questions/40052529/in-rxjs-5-is-there-a-way-to-trigger-an-observable-before-subscribing-to-it?rq=1"}},"asked in this Stackoverflow"),", you sometimes want to kick off a long-running piece of work before you actually subscribe to an observable. For example:"),s.a.createElement(i.MDXTag,{name:"pre",components:n},s.a.createElement(i.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-swift",metaString:""}},"func longRunningTask() -> Observable<Result> {\n    return Observable.create { observer in\n        doSomeLongRunningWork { result in\n            observer.onNext(result)\n            observer.onCompleted()\n        }\n    }\n}\n\nfunc startTask() {\n    let connectable = longRunningTask().publish()\n    connectable.connect() // start the task\n\n    // Do more setup...\n\n    connectable.subscribe(onNext: { result in\n        // process the result\n    })\n}\n")),s.a.createElement(i.MDXTag,{name:"p",components:n},"Hopefully this helps explain an unintuitive concept for others who are starting out with reactive programming. If you know a better way or a best practice to do this sort of thing, ",s.a.createElement(i.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://twitter.com/noahsark769"}},"let me know"),"! For reference, I've implemented these examples on ",s.a.createElement(i.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/noahsark769/RxSwift-practice/blob/ca092d91791e40a98980607c0d72caa774d1a509/rxswift-practice/Tests.swift#L85"}},"Github"),"."))};var m={}}}]);
//# sourceMappingURL=component---src-pages-blog-rxswift-multiple-subscribers-mdx-27777b6f28afefd31bc2.js.map