(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{152:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",function(){return p});var a=t(158),o=t.n(a),r=t(0),i=t.n(r),m=t(159),c=t(160),s=t(177);n.default=function(e){var n=e.components,t=o()(e,["components"]);return i.a.createElement(m.MDXTag,{name:"wrapper",Layout:c.a,layoutProps:t,components:n},i.a.createElement(m.MDXTag,{name:"p",components:n},"At the most recent ",i.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://www.meetup.com/swift-language/"}},"Swift Language User Group")," meetup, ",i.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://twitter.com/patbarry"}},"Patrick Barry")," presented a ",i.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://www.youtube.com/watch?v=dA9rGQRwHGs"}},"great talk")," about how Lyft implements dependency injection. I'd highly recommend watching the video - I was impressed by how clean and functional the solution they came up with is. I was going to write up a summary for my coworkers, but figured I might as well put it here for the benefit of anyone who's interested."),i.a.createElement(m.MDXTag,{name:"p",components:n},"This post describes the very simple approach to dependency injection presented in the talk, using new functions ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"bind")," and ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mock"),". I'll paraphrase some code in this write up, but the concepts and function names will match the talk."),i.a.createElement(m.MDXTag,{name:"h2",components:n},"Dependency Injection"),i.a.createElement(m.MDXTag,{name:"p",components:n},"I won't go into detail on what dependency injection is, since there's a fair amount of time in the talk dedicated to it. Instead, let's think about an example."),i.a.createElement(m.MDXTag,{name:"p",components:n},"Say we're writing an app to display info about cats. We would have a ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Cat")," model in our app:"),i.a.createElement(m.MDXTag,{name:"pre",components:n},i.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-swift",metaString:""}},"struct Cat: Codable {\n    let name: String\n    let image: URL\n}\n")),i.a.createElement(m.MDXTag,{name:"p",components:n},"And let's assume we have an API to fetch a cat by name:"),i.a.createElement(m.MDXTag,{name:"pre",components:n},i.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{metaString:null}},'GET /cat?id=2\n{\n    "name": "Maggie",\n    "image": "https://placekitten.com/200/200"\n}\n')),i.a.createElement(m.MDXTag,{name:"p",components:n},"From an architectural point of view, we want to extract this into two different parts:"),i.a.createElement(m.MDXTag,{name:"ol",components:n},i.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"A ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"NetworkService")," which makes the requests"),i.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"A ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"CatService")," which exposes a ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"getCat(id:)")," method (this calls into the network service)")),i.a.createElement(s.a,{filename:"swift-di-1.png",alt:"Diagram of CatService calling NetworkService",caption:""}),i.a.createElement(m.MDXTag,{name:"h2",components:n},"Binding"),i.a.createElement(m.MDXTag,{name:"p",components:n},"There's a clear ",i.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"#seam"}},"seam")," between the ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"NetworkService")," and ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"CatService")," that we can use to test ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"CatService"),". Let's extract the network's functionality into an interface:"),i.a.createElement(m.MDXTag,{name:"pre",components:n},i.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-swift",metaString:""}},"protocol NetworkInterface {\n    func makeRequest(\n        url: URL,\n        completion: @escaping (Result<Data, Error>) -> Void\n    )\n}\n")),i.a.createElement(m.MDXTag,{name:"p",components:n},"And the concrete implementation:"),i.a.createElement(m.MDXTag,{name:"pre",components:n},i.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{metaString:null}},"private class NetworkService: NetworkInterface {\n    func makeRequest(\n        url: URL,\n        completion: @escaping (Result<Data, Error>) -> Void\n    ) {\n        // Use URLSession, etc\n    }\n}\n")),i.a.createElement(m.MDXTag,{name:"p",components:n},"And now for the really interesting part - ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"NetworkService")," will ",i.a.createElement(m.MDXTag,{name:"em",components:n,parentName:"p"},"expose itself using a special function called bind"),' (I\'ve added the "SimpleDI" namespace here):'),i.a.createElement(m.MDXTag,{name:"pre",components:n},i.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-swift",metaString:""}},"let getNetwork = SimpleDI.bind(NetworkInterface.self) { NetworkService() }\n")),i.a.createElement(m.MDXTag,{name:"p",components:n},i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"bind")," returns ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"getNetwork")," as a function which can be called to get a concrete implementation of the ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"NetworkInterface")," protocol. ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"CatService")," can then call ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"getNetwork")," to get access to the network:"),i.a.createElement(m.MDXTag,{name:"pre",components:n},i.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{metaString:null}},"class CatService {\n    func getCat(id: Int, completion: @escaping (Result<Cat, Error>) -> Void) {\n        let network = getNetwork()\n        network.makeRequest(/* ... */)\n    }\n}\n")),i.a.createElement(s.a,{filename:"swift-di-2.png",alt:"Diagram of CatService calling NetworkService, with bind as an intermediary",caption:""}),i.a.createElement(m.MDXTag,{name:"h2",components:n},"Implementation"),i.a.createElement(m.MDXTag,{name:"p",components:n},"Before we talk about why ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"bind")," is useful, let's discuss the implementation. ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"bind")," returns a function which takes no parameters and returns a type of ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"NetworkInterface"),", but it also takes a closure which will be used to generate the concrete implementation."),i.a.createElement(m.MDXTag,{name:"p",components:n},i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"bind"),"'s body looks like this (again, paraphrased a bit from the talk):"),i.a.createElement(m.MDXTag,{name:"pre",components:n},i.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-swift",metaString:""}},"private var instantiators: [String: Any] = [:]\n\nenum SimpleDI {\n    static func bind<T>(\n        _ interfaceType: T.Type,\n        instantiator: @escaping () -> T\n    ) -> () -> T {\n        instantiators[String(describing: interfaceType)] = instantiator\n        return self.instance\n    }\n\n    private static func instance<T>() -> T {\n        let key = String(describing: T.self)\n        let instantiator = instantiators[key] as! () -> T\n        return instantiator()\n    }\n}\n")),i.a.createElement(m.MDXTag,{name:"p",components:n},"We take the closure that we're passed and save it in a dictionary (",i.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"#dictionary-atomic"}},"see end note"),"), then return a function which accesses and calls the closure we provided. Though we have to do some force casting, we're guaranteed that the closure we need will be there when ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"getNetworkInterface")," is called, since we put it into ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"instantiators")," before returning from ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"bind"),"."),i.a.createElement(m.MDXTag,{name:"h2",components:n},"Testability"),i.a.createElement(m.MDXTag,{name:"p",components:n},"Using ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"bind")," adds a level of indirection at the seam between ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"NetworkService")," and ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"CatService"),", which allows us to stub in a mock in tests. In order to do that, we need to define ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mock")," as well, and add a bit of more infrastructure:"),i.a.createElement(m.MDXTag,{name:"pre",components:n},i.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-swift",metaString:""}},'private var instantiators: [String: Any] = [:]\nprivate var mockInstantiators: [String: Any] = [:]\n\nenum SimpleDI {\n    static var isTestEnvironment = false\n\n    static func bind<T>(\n        _ type: T.Type,\n        instantiator: @escaping () -> T\n    ) -> () -> T {\n        instantiators[String(describing: type)] = instantiator\n        return self.instance\n    }\n\n    private static func instance<T>() -> T {\n        let key = String(describing: T.self)\n        if self.isTestEnvironment {\n            guard let instantiator = mockInstantiators[key] as? () -> T else {\n                fatalError("Type \\(key) unmocked in test!")\n            }\n            return instantiator()\n        }\n        let instantiator = instantiators[key] as! () -> T\n        return instantiator()\n    }\n\n    static func mock<T>(_ type: T.Type, instantiator: @escaping () -> T) {\n        mockInstantiators[String(describing: type)] = instantiator\n    }\n}\n')),i.a.createElement(m.MDXTag,{name:"p",components:n},"This code isn't very pretty - in fact, checks like ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"isTestEnvironment")," are generally a code smell that mean you should refactor how the class works to avoid the check. However, this enables us to write tests very easily: all we have to do is set ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"isTestEnvironment = true"),", and we'll be able to ",i.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"#mock"}},"stub in a mock")," immediately using ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mock"),"."),i.a.createElement(m.MDXTag,{name:"h2",components:n},"Example"),i.a.createElement(m.MDXTag,{name:"p",components:n},"Let's say we want to write a test which makes sure CatService reports an error when the underlying network errors:"),i.a.createElement(m.MDXTag,{name:"pre",components:n},i.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{metaString:null}},'class NetworkThatAlwaysErrors: NetworkInterface {\n    func makeRequest(url: URL, completion: @escaping (Result<Data>) -> Void) {\n        completion(.error(error: NSError(domain: "", code: 0, userInfo: nil)))\n    }\n}\n\nclass CatServiceTestCase: XCTestCase {\n    func testCatServiceReportsError() {\n        SimpleDI.isTestEnvironment = true\n        SimpleDI.mock(NetworkInterface.self) { NetworkThatAlwaysErrors() }\n\n        let expecation = self.expectation(description: "Should return error")\n        let service = CatService()\n        service.getCatImage(named: "Maggie", completion: { result in\n            if case .error = result {\n                expecation.fulfill()\n            }\n        })\n        self.waitForExpectations(timeout: 0.2)\n    }\n}\n')),i.a.createElement(m.MDXTag,{name:"p",components:n},i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"bind")," and ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mock")," take the dirty work of setting up the DI/mocking infrastructure and hide it under the rug, allowing us to write more expressive tests easily."),i.a.createElement(s.a,{filename:"swift-di-3.png",alt:"Diagram of bind and mock being used to separate CatService and NetworkService and stub in a mock in tests",caption:""}),i.a.createElement(m.MDXTag,{name:"p",components:n},"Some interesting things to note:"),i.a.createElement(m.MDXTag,{name:"ol",components:n},i.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},"Many people who've worked with DI have horror stories of passing 10/15+ dependencies into an initializer so they can be mocked in tests. ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"bind")," brings the argument count down to 0 without sacrificing testability, and makes both the service and the test more elegant."),i.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"bind")," will error if you forget to mock out an interface in a test, so you're never accidentally calling deeper into dependencies than you mean to.")),i.a.createElement(m.MDXTag,{name:"h2",components:n},"Conclusion"),i.a.createElement(m.MDXTag,{name:"p",components:n},"It was really interesting to see how Lyft was able to come up with such a simple solution to a complex problem. I'm hoping to implement this in personal projects and do some more thinking on what the pros and cons to this approach are. I'd really recommend watching ",i.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://www.youtube.com/watch?v=dA9rGQRwHGs"}},"the talk")," if you're interested in dependency injection and testing. If you'd like to see a working example of ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"bind")," and ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"mock"),", I've put one ",i.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/noahsark769/NGSimpleDIExample"}},"here")," (it has a few differences from the code in this post in order to demonstrate an actual working request and test)."),i.a.createElement(m.MDXTag,{name:"h2",components:n},"Footnotes"),i.a.createElement(m.MDXTag,{name:"ol",components:n},i.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},i.a.createElement("a",{name:"dictionary-atomic"}),"Dictionary is not thread safe, so if you want to use ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"bind")," and ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"mock")," on multiple threads you'll need to implement something similar to an ",i.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"https://www.objc.io/blog/2018/12/18/atomic-variables/"}},"atomic box")," (the talk mentions this)."),i.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},i.a.createElement("a",{name:"seam"}),'"',i.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"http://wiki.c2.com/?SoftwareSeam"}},"Seam"),'" is a concept that seems to have been first coined in ',i.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052"}},"Working Effectively With Legacy Code"),". It's defined as \"",i.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"li",props:{href:"https://softwareengineering.stackexchange.com/questions/132563/problem-with-understanding-seam-word/311122"}},"a place where two parts of the software meet and where something else can be injected"),'".'),i.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ol"},i.a.createElement("a",{name:"mock"}),"You could even put ",i.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"mock")," in your test target to make sure it can't be called in production!")))};var p={}},177:function(e,n,t){"use strict";t.d(n,"a",function(){return l});var a=t(7),o=t.n(a),r=t(0),i=t.n(r),m=t(155),c=t(184),s=m.c.div.withConfig({displayName:"CaptionedImage__Container",componentId:"ceijyq-0"})(["margin:20px 0;"]),p=m.c.div.withConfig({displayName:"CaptionedImage__Caption",componentId:"ceijyq-1"})(['font-family:"Gentium Book Basic",times,serif;font-style:italic;font-size:16px;color:#999;margin-bottom:30px;img{width:100%;margin-bottom:10px;}']),l=function(e){function n(){return e.apply(this,arguments)||this}return o()(n,e),n.prototype.render=function(){return i.a.createElement(s,null,i.a.createElement(c.a,{filename:this.props.filename,alt:this.props.alt}),i.a.createElement(p,null,this.props.caption))},n}(i.a.Component)}}]);
//# sourceMappingURL=component---src-pages-blog-swift-dependency-injection-mdx-5754d24ad211a7cb8e98.js.map