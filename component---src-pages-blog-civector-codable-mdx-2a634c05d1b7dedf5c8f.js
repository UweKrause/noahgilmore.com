(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{141:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",function(){return s});var a=t(158),o=t.n(a),r=t(0),c=t.n(r),p=t(159),m=t(160);n.default=function(e){var n=e.components,t=o()(e,["components"]);return c.a.createElement(p.MDXTag,{name:"wrapper",Layout:m.a,layoutProps:t,components:n},c.a.createElement(p.MDXTag,{name:"p",components:n},"For my current ",c.a.createElement(p.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://twitter.com/noahsark769/status/1102318232025718785"}},"side project"),", I have to export CIFilter parameters to json, and I've been running into issues with various CoreImage types not conforming to Swift's ",c.a.createElement(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Codable"),". ",c.a.createElement(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"CIColor")," is easy enough to encode and decode, but ",c.a.createElement(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"CIVector")," (which represents an arbitrary length list of ",c.a.createElement(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"CGFloats"),") is trickier."),c.a.createElement(p.MDXTag,{name:"p",components:n},"Thought I'd share a wrapper type which I use to encode and decode ",c.a.createElement(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"CIVector"),":"),c.a.createElement(p.MDXTag,{name:"pre",components:n},c.a.createElement(p.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-swift",metaString:""}},"struct CIVectorCodableWrapper {\n    let vector: CIVector\n}\n\nextension CIVectorCodableWrapper: Codable {\n    public init(from decoder: Decoder) throws {\n        var container = try decoder.unkeyedContainer()\n        var floats: [CGFloat] = []\n        while !container.isAtEnd {\n            floats.append(try container.decode(CGFloat.self))\n        }\n        vector = CIVector(floats: floats)\n    }\n\n    func encode(to encoder: Encoder) throws {\n        var container = encoder.unkeyedContainer()\n        for i in 0..<vector.count {\n            try container.encode(vector.value(at: i))\n        }\n    }\n}\n")),c.a.createElement(p.MDXTag,{name:"p",components:n},c.a.createElement(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"CIVector"),' is semantically an "unkeyed container" type, so the ',c.a.createElement(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Codable")," implementation encodes the vector's floats to an unkeyed coding container (with ",c.a.createElement(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"JSONEncoder"),", for example, this becomes an array)."))};var s={}}}]);
//# sourceMappingURL=component---src-pages-blog-civector-codable-mdx-2a634c05d1b7dedf5c8f.js.map